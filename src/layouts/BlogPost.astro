---
import type { MarkdownHeading } from 'astro'
import type { CollectionEntry } from 'astro:content'
import config from 'virtual:config'

// Plugin styles
import 'katex/dist/katex.min.css'

import { MediumZoom } from 'astro-pure/advanced'
import { ArticleBottom, Copyright, Hero, TOC } from 'astro-pure/components/pages'
import Signature from '../../packages/pure/components/user/Signature.astro'
import PageLayout from '@/layouts/ContentLayout.astro'
import { Comment, PageInfo } from '@/components/waline'
import RelatedArticles from '@/components/RelatedArticles.astro'
import { integ } from '@/site-config'

interface Props {
  post: CollectionEntry<'blog'>
  posts: CollectionEntry<'blog'>[]
  headings: MarkdownHeading[]
  remarkPluginFrontmatter: Record<string, unknown>
}

const {
  post,
  post: { id, data },
  posts,
  headings,
  remarkPluginFrontmatter
} = Astro.props

const {
  description,
  heroImage,
  publishDate,
  title,
  updatedDate,
  draft: isDraft,
  comment: enableComment
} = data

const socialImage = heroImage
  ? typeof heroImage.src === 'string'
    ? heroImage.src
    : heroImage.src.src
  : '/images/social-card.png'
const articleDate = updatedDate?.toISOString() ?? publishDate.toISOString()
const primaryColor = data.heroImage?.color ?? 'hsl(var(--primary) / var(--un-text-opacity))'
const isEncryptedPost = Boolean((data as any).encrypted && (data as any).encryption)
---

<PageLayout
  meta={{ articleDate, description, ogImage: socialImage, title }}
  highlightColor={primaryColor}
  back='/blog'
>
  {!!headings.length && <TOC {headings} slot='sidebar' />}

  <Hero {data} {remarkPluginFrontmatter} slot='header'>
    <Fragment slot='description'>
      {!isDraft && enableComment && <PageInfo comment class='mt-1' />}
    </Fragment>
  </Hero>

  {!isEncryptedPost && <slot />}

  {isEncryptedPost && (
    <div id='encrypted-post'
      data-alg={(data as any).encryption.alg ?? 'AES-256-GCM'}
      data-iv={(data as any).encryption.iv}
      data-ciphertext={(data as any).encryption.cipherText}
      data-wrappedkey={(data as any).encryption.wrappedKey}
      data-prf-salt={(data as any).encryption.prfSalt}
      data-allowcreds={JSON.stringify((data as any).encryption.allowCredentials ?? [])}
      class='rounded-lg border p-4 my-4'
    >
      <div class='flex items-center gap-3'>
        <span class='i-heroicons-lock-closed-20-solid text-xl' aria-hidden='true'></span>
        <div>
          <p class='font-medium'>该文章已加密</p>
          <p class='text-sm text-muted-foreground'>使用通行密钥解锁以阅读内容</p>
        </div>
      </div>
      <div class='mt-3 flex items-center gap-2'>
        <button id='unlock-btn' class='btn btn-primary'>解锁文章</button>
        <span id='unlock-status' class='text-sm text-muted-foreground'></span>
      </div>
      <div id='decrypted-content' class='mt-4 hidden'></div>
      <noscript>
        <p class='text-sm text-red-500 mt-3'>需要启用 JavaScript 才能解锁阅读。</p>
      </noscript>
    </div>
  )}

  {config.signature && <Signature />}
  <Fragment slot='bottom'>
    {/* Copyright */}
    <Copyright {data} />
    {/* Related Articles */}
    <RelatedArticles currentPost={post} allPosts={posts} />
    {/* Article recommend */}
    <ArticleBottom collections={posts} {id} class='mt-3 sm:mt-6' />
    {/* Comment */}
    {!isDraft && enableComment && <Comment class='mt-3 sm:mt-6' />}
  </Fragment>

  <slot name='bottom-sidebar' slot='bottom-sidebar' />
</PageLayout>

{integ.mediumZoom.enable && <MediumZoom />}

{isEncryptedPost && (
  <script type='module'>
    const container = document.getElementById('encrypted-post')
    const unlockBtn = document.getElementById('unlock-btn')
    const statusEl = document.getElementById('unlock-status')
    const outputEl = document.getElementById('decrypted-content')

    function setStatus(msg, kind = 'info') {
      if (!statusEl) return
      statusEl.textContent = msg
      statusEl.className = 'text-sm ' + (kind === 'error' ? 'text-red-500' : kind === 'ok' ? 'text-green-600' : 'text-muted-foreground')
    }

    const b64urlToBytes = (s) => {
      s = s.replace(/-/g, '+').replace(/_/g, '/')
      const pad = s.length % 4
      if (pad) s = s + '='.repeat(4 - pad)
      const binStr = atob(s)
      const bytes = new Uint8Array(binStr.length)
      for (let i = 0; i < binStr.length; i++) bytes[i] = binStr.charCodeAt(i)
      return bytes
    }
    const bytesToB64url = (buf) => {
      const b64 = btoa(String.fromCharCode(...new Uint8Array(buf)))
      return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '')
    }

    async function deriveWrappingKey(prfSaltBytes, allowCreds) {
      if (!('credentials' in navigator)) throw new Error('此浏览器不支持 WebAuthn')

      const challenge = crypto.getRandomValues(new Uint8Array(32))
      const publicKey = {
        challenge,
        userVerification: 'preferred',
      }
      if (Array.isArray(allowCreds) && allowCreds.length) {
        publicKey.allowCredentials = allowCreds.map((idB64) => ({
          type: 'public-key',
          id: b64urlToBytes(idB64),
          transports: ['internal', 'hybrid', 'usb', 'nfc', 'ble']
        }))
      }
      publicKey.extensions = { prf: { eval: { first: prfSaltBytes } } }

      const cred = await navigator.credentials.get({ publicKey })
      const ext = cred.getClientExtensionResults && cred.getClientExtensionResults()
      const prf = ext && ext.prf
      if (!prf || !prf.results || !prf.results.first) throw new Error('通行密钥不支持 PRF，或被拒绝')
      const prfBytes = new Uint8Array(prf.results.first)
      const wrappingKey = await crypto.subtle.importKey('raw', prfBytes, 'AES-KW', false, ['wrapKey', 'unwrapKey'])
      return wrappingKey
    }

    async function decryptPost() {
      try {
        setStatus('请求通行密钥…')
        const iv = b64urlToBytes(container.dataset.iv)
        const cipherBytes = b64urlToBytes(container.dataset.ciphertext)
        const wrappedKeyBytes = b64urlToBytes(container.dataset.wrappedkey)
        const prfSalt = b64urlToBytes(container.dataset.prfSalt)
        const allowCredIds = JSON.parse(container.dataset.allowcreds || '[]')

        const wrappingKey = await deriveWrappingKey(prfSalt, allowCredIds)
        setStatus('解锁内容密钥…')
        const cek = await crypto.subtle.unwrapKey(
          'raw',
          wrappedKeyBytes.buffer,
          wrappingKey,
          'AES-KW',
          { name: 'AES-GCM', length: 256 },
          false,
          ['decrypt']
        )

        setStatus('解密文章内容…')
        const plaintext = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, cek, cipherBytes)
        const html = new TextDecoder().decode(plaintext)
        outputEl.innerHTML = html
        outputEl.classList.remove('hidden')
        setStatus('已解锁', 'ok')
        if (unlockBtn) unlockBtn.classList.add('hidden')
      } catch (e) {
        console.error(e)
        setStatus('解锁失败：' + (e && e.message ? e.message : '未知错误'), 'error')
      }
    }

    unlockBtn?.addEventListener('click', () => {
      decryptPost()
    })
  </script>
)}
